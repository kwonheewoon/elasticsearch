* 샤드 레벨 요청 캐시
    샤드 레벨 요청 캐시(request cache)는 검색 수행 시 query 페이즈에서 수행된 작업을 샤드 레벨에 저장하는 캐시다.

    * 캐시 수행 위치
        요청 캐시는 SearchQueryThenFetchAsyncAction 작업 이후 QueryPhase 작업에 들어갈 때 동작한다.
        QueryPhase 클래스의 execute가 수행되기 전 SearchService의 executeSearch 메서드에서 캐시 작업이 수행된다.
        먼저 들어온 ShardSearchRequest와 대상 인덱스 설정을 보고 캐시 가능한 요청인지 여부를 파악한다.

    * 캐시 조건
        엘라스틱서치가 검색 수행 시 요청 캐시를 활용하려면 다음 조건을 만족해야 한다. 기본적으로
        search_type이 query_then_fetch여야 하고, scroll 검색이 아니어야 하며, profile 요청이 아니어야 한다.
        또한 now가 포함된 날짜 시간 계산 표현이나 Math.random(), new Date() 같은 명령이 포함된 스크립트 등 확정되지 않은
        형태의 조건이 들어간 검색도 캐시 대상에서 빠진다. 이러한 기본 조건을 만족한다면 샤드 레벨 요청 캐시를 적용하도록 설정했는지 확인한다.
        먼저 검색 api를 호출할때 requestCache 매개변수를 명시적으로 true 혹은 false로 지정했는지 여부를 확인한다.
        명시적으로 true로 설정했다면 캐시 대상으로, false로 설정했다면 캐시 대상이 아닌 것으로 판정한다.
        만약 requestCache 매개변수를 명시적으로 지정하지 않았다면 index.requests.cache.enable 인덱스 설정 값을 확인한다.
        별도로 설정하지 않았다면 기본값은 true다. 이 값이 false면 캐시 대상이 아닌 것으로 판정한다.
        이 값이 true면 검색 요청의 size 매개변수가 0인지를 검사해서 0인 경우에만 캐시 대상으로 판정한다

        ** 샤드 레벨 요청 캐시 대상인 검색인지 판단하는 과정을 표현한 의사코드
            public boolean canCache(ShardSearchRequest request, SearchContext context) {
                if (!기본 조건) {
                    return false;
                }

                final Boolean requestCache = request.requestCache();
                if (requestCache == null) {
                    if (settings.getValue(INDEX_CACHE_REQUEST_ENABLED) && context.size() == 0) {
                        return true;
                    }

                    return false;
                }

                return requestCache;
            }

            명시적으로 requestCache를 true로 지정하면 size 0 여부와 상관없이 캐시를 수행한다.
            명시적 설정 없이 모든 설정을 기본값으로 둔 동작에서는 size를 0으로 지정한 요청만 캐시한다.

    * 캐시 키
        요청이 캐시 대상이라는 사실을 확인하고 나면 캐시 키를 만든다. 캐시 키는 두 단계를 거쳐 생성한다.
        먼저 ShardSearchRequest의 주요 내용을 바이트로 직렬화한다. 여기에는 인덱스, 샤드 번호와 검색 요청의 본문 내용이 포함된다.
        즉 사실상 완전히 같은 검색 요청이어야 캐시가 적중되는 구조다.

        다음 단계에서는 SearchPlugin 인터페이스의 getRequestCacheKeyDifferentiator 메서드를 오버라이드한 플러그인에서
        지정한 캐시 키 변경 로직을 적용한다. 엘라스틱서치 노드 기동 과정에서 기본 내장 보안 모듈인 Security 플러그인이 이를 이용해
        캐시 키 변경 로직을 등록한다. 문서나 필드에 접근할 수 있는 권한이 있는지를 파악해서 캐시 키를 변경한다.
        인가되지 않은 사용자가 캐시에 올라간 데이터를 받아가지 않게 하기 위한 로직이다.
        이 작업을 등록할 수 있는 플러그인은 한 엘라스틱서치 노드에 하나로 제한되어 있다. 커스텀 플로그인 레벨에서는 상당히 과격한
        방법을 동원하지 않는 이상 캐시 키 변경 로직을 끼워넣기 어렵다.

    * 캐시 대상 값
        캐시 키를 만든 후에는 이 키로 캐시에 올라간 데이터가 있는지 찾는다. 캐시가 적중했다면
        쿼리 매치 작업을 수행하지 않고 캐시된 값을 바로 이용한다. 캐시 부적중 시 QueryPhase의 execute를 수행해
        쿼리 매치 작업을 진행한다. 그리고 그 결과를 바이트로 직렬화해 캐시에 적재한다. 이때 캐시에 올라가는 값은
        QueryPhase를 통해 얻는 거의 모든 데이터다. 제안 결과, 집계 결과는 물론 매치된 문서 수,
        최대 점수, 매치된 상위 문서가 무엇이고 점수가 얼마인지까지 모두 캐시된다.

    * 샤드 레벨 요청 캐시 활용 방향
        이제 다시 size 0 검사를 되짚어 보다. 샤드 레벨 요청 캐시의 주 목적 자체가 size를 0으로 지정해 요청하는 집계 결과를 캐시하는 것이다.
        기본적으로 집계 작업은 무겁기 때문이다. 또한 샤드 레벨 요청 캐시는 QueryPhase의 작업 결과를 캐시한다.
        FetchPhase의 결과를 캐시하는 것이다. 매치된 상위 문서가 무엇인지, 유사도 점수가 얼마인지는 캐시에서 가져올 수 있지만
        그 문서의 _source는 FetchPhase를 통해서 가져와야 한다. 그러므로 집계를 지정하지 않는 일반적인 검색 요청의 쿼리 매치 작업 결과를 캐시하는 것은
        집계 작업을 캐시하는 것보다 힙 사용량 대비 캐시 효율성이 떨어진다. 기본 동작이 size 0인 검색 요청만을 캐시하는 까닭도 이 때문이다.

        그러나 일반적인 검색이 샤드 레벨 요청 캐시의 혜택을 누리지 못하는 것이 결코 아니라는 사실은 매우 중요하다.
        서비스 특성상 엘라스틱서치 클러스터의 주 사용 용도가 집계가 아닌 일반 검색이고 동일한 쿼리가 여러 번 인입될 가능성이 있다면 요청 캐시를
        적극적으로 사용하는 것도 좋다.
        requestCache 매개변수를 명시적으로 true로 지정해 요청하자. 특히 검색 성능에 민감한 서비스라면
        더욱 그렇다. FetchPhase의 작업을 더 수행해야 하기는 하지만 QueryPhase의 주된 작업 자체를 캐시 적중으로 해결하는 것만으로도 실제
        성능 차이가 크다. 클러스터가 다루는 데이터가 크다면 쿼리에 매치되는 문서의 수도 많고 이를 DocIdSetIterator로 순회하는 작업,
        문서를 하나씩 순회하며 유사도 점수를 계산하는 작업, Collector가 최소 경쟁력 유사도 점수를 매겨가며 상위 문서를 수집하는 작업등의
        부담도 크다. 샤드 레벨 요청 캐시를 사용하면 위 작업을 전부 건너 띌수 있다.

    * 캐시가 적재되는 위치
        엘라스틱서치 노드가 기동하는 과정에서 Node 클래스 생성자가 호출되며, 여기서 IndicesService 인스턴스가 생성된다.
        이 IndicesService 인스턴스는 AbstractLifecycleComponent 인터페이스를 구현하고 있어 노드가 생명 주기를 같이한다.
        IndicesService 인스턴스를 생성할 때 생성자는 IndicesRequestCache 인스턴스를 생성하고 필드에 저장한다.
        IndicesRequestCache 인스턴스는 Cache 인스턴스를 만들어 필드에 저장한다.
        이 cache 인스턴스에 샤드 레벨 요청 캐시가 적재된다.

        1. Elasticsearch main() 최소 시작 지점인 main 메서드
        2. Node() 주요 모듈, 서비스, 구성 요소를 생성
        3. IndicesService extends AbstractLifecycleComponent 인덱스와 관련된 작업을 담당하는 서비스 생명 주기가 노드의 생명 주기와 같고
            노드당 1개의 인스턴스만 생성됨
            IndicesRequestCache Cache<Key, BytesReference> 샤드 레벨 요청 캐시
            Key = 인덱스, 샤드 번호, 검색 요청 본문등 바이트 직렬화 값
            BytesReference = QueryPhase의 수행 결과 대부분(매치된 문서 수, 최대 점수, 매치된 상위 문서와 그 점수, 제안 결과, 집계 결과 등)

    * 캐시 상태 확인
        GET _stats/request_cache?human

    * 캐시 크기 지정과 캐시 무효화
        기본 설정으로는 총 힙의 1%까지 샤드 레벨 요청 캐시로 사용한다. config/elasticsearch.yml
        에 다음과 같이 설정한 뒤 노드를 재기동하면 이 값을 변경할 수 있다.
        샤드 레벨 요청 캐시는 인덱스 refresh를 수행할 때 무효화 된다.


* 노드 레벨 쿼리 캐시
    노드 레벨 쿼리 캐시는 필터 문맥으로 검색 수행 시 쿼리에 어떤 문서가 매치됐는지를 노드 레벨에 저장하는 캐시다.

    * 캐시 수행 위치
        QueryPhase에서 검색 수행 시 IndexSearcher의 search 메서드를 호출한다. 여기서 Query의 createWeight를 호출해
        Weight를 생성한다. 이때 유사도 점수를 계산하지 않는 Query라면 쿼리 캐시를 적용하는 CachingWeightWrapper로 감싸 최종 Weight를 반환
        이 Weight를 가지고 검색을 수행하는 과정에서 BulkScorer나 Scorer가 캐시된 DocIdSet을 순회하는 DocIdSetIterator를 반환

    * 캐시 대상 값
        캐시에 적재하는 값인 DocIdSet 추상 클래스는 쿼리에 매치된 문서 목록을 나타낸다. 여러 DocIdSet의 구현체가 있지만 주로 비트 배열로 구현한다.
        추상화해 예를 들자면 4번 문서가 매치된 경우 배열의 4번 비트를 1로 올린다.

        매치된 문서 수가 검색 대상 문서 수의 1%를 초과하면 밀도가 높은 배열로 취급, 그러한 경우에는 DocIdSet의 구현체로 FixedBitSet을 사용
        비트 배열이므로 AND 검색 등에서 DocIdSetIterator를 순회할 때 최적화가 된다. 밀도 높은 배열이 아니라면 메모리를 덜 사용하는 RoaringDocIdset
        구현체를 사용한다. 다만 밀도에 대한 추정은 Scorer의 cost 메서드를 사용한다. 즉 쿼리의 종류에 따라 결과가 상이하며, 정확하게 1%가 측정되는 것은 아니다

    * 캐시 키
        캐시의 키는 Query다. 즉 Query의 equals와 hashCode 구현상 같은 Query로 취급할 수 있는 쿼리가 들어와야 캐시를 적중시킬 수 있다.

    * bool 쿼리에서 노드 레벨 쿼리 캐시 활용
        쿼리 문맥과 필터 문맥을 모두 가지고 있는 bool 쿼리는 어떻게 캐싱될까
        BooleanWeright의 생성자는 BooleanQuery에 지정된 모든 하위 Query를 가지고 IndexSearcher의 createWeight를 호출한다.
        이러면 createWeight 과정에서 각 하위 Query가 생성하는 Weight 중 유사도 점수 계산이 필요없는 Weight만 CachingWeightWrapper로
        생성한다. 즉 쿼리 중 일부분인 필터 문맥 부분만 잘 분리해 캐시한다. 이는 완전히 같은 Query를 반복 수행할 때만 캐시의 혜택을 보는게
        아니라는 의미다. 여러 bool 쿼리의 내용을 바꿔가며 수행하더라도 필트 문맥의 하위 쿼리 중 일부가 겹친다면
        부분적으로 캐시의 혜택을 본다. 따라서 캐시 적중률과 성능을 높이려면 필터 문맥을 최대한 활용하는 것이 중요하다.


    * 캐시 조건
        캐시를 활용하기 위해서는 유사도 점수를 계산하지 않는 쿼리여야 한다는 점 외에도 1만개 이상의 문서가 있으며 동시에 샤드 내 문서의
        3% 이상을 보유하고 있는 세그먼트가 대상일 때만 캐시한다. 내부 테스트에만 사용하는 설정을 지정하는 방법으로 해당 조건을 아예
        제거할 수는 있지만 1만과 3%라는 숫자는 바꿀수 없다.
        이 외에도 쿼리 캐시 없이도 충분히 빠르다고 판단하는 쿼리는 캐시하지 않는다. TermQuery, MatchAllDocsQuery, MatchNoDocsQuery
        DocValuesFieldExistsQuery 등이다

    * 락 획득
        노드 레벨 쿼리 캐시는 읽기 작업과 쓰기 작업에 모두 락 획득을 필요로 한다. 다만 읽기 작업도중 락 획득을 무작정 기다릴 수는 없다.
        다른 스레드가 락을 잡고 있어 최초 락 획득 시도가 실패하면 바로 일반 검색 작업으로 진행

    * 캐시가 적재되는 위치
        엘라스틱서치 노드 기동 과정에서 IndicesService 인스턴스를 생성할 때 생성자에서 IndicesQueryCache 인스턴스를 생성해 필드에 저장
        한 노드에서 생성하는 모든 IndexSearcher가 IndicesQueryCache 인스턴스를 공유한다. 이 IndicesQueryCache의 내부 구현 깊숙한 곳에
        노드 레벨 쿼리 캐시가 적재된다. IndicesService의 생명주기는 노드의 생명주기와 같으므로 쿼리 캐시는 노드레벨 캐시다

        1. Elasticsearch main()
        2. Node()   주요 모듈, 서비스, 구성 요소를 생성
        3. IndicesService extends AbstractLifecycleComponent
            IndicesRequestCache Cache<Key, BytesReference> // 샤드레벨 요청 캐시
            IndicesQueryCache LRUQueryCache // 노드레벨 쿼리 캐시( 캐시 대상 값은 매치된 문서 목록을 나타내는 비트 배열 )


    * 캐시 상태 확인
        노드 레벨 쿼리 캐시 상태를 확인하려면 다음과 같이 호출
        GET _stats/query_cache?human

    * 캐시 크기 지정과 캐시 무효화
        기본 설정으로는 총 힙의 10%까지 노드 레벨 쿼리 캐시로 사용
        노드 레벨 쿼리 캐시도 인덱스 refresh를 수행할 때 무효화 한다.

* 운영체제 레벨 페이지 캐시
    운영체제는 디스크에서 데이터를 읽은 후 데이터를 메모리에 넣어 두었다가 다시 이 데이터를 읽을 일이 있으면 디스크가 아니라
    메모리에서 읽어 반환한다. 엘라스틱서치는 페이지 캐시를 잘 활용하고 있으므로 시스템 메모리의 절반 이상은 캐시로 사용하도록 설정하는 것이 좋다.