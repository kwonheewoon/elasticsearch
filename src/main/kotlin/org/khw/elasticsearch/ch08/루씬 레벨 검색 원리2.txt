* Collector

    루씬에서의 Collector는 검색 결과를 수집하는 주요 인터페이스로서,
    검색된 문서들 중에서 실제로 필요한 정보를 어떻게 선택하고 처리할지를 결정합니다.
    이 인터페이스를 통해 유사도 점수나 문서의 정렬 순서를 계산하며, 가장 관련성 높은 결과들을 모으는 등의 역할을 합니다.

    Collector 인터페이스는 LeafCollector라는 인스턴스를 생성하는 getLeafCollector 메서드를 제공합니다.
    LeafCollector는 실제로 개별 세그먼트(LeafReader 문맥)에서 문서를 수집하는 역할을 담당합니다.
    검색 과정에서는 다양한 세그먼트를 순회하며, 각 세그먼트에서 필요한 문서를 수집할 때마다 LeafCollector 인스턴스를 교체하게 됩니다.

    Collector의 주요 메서드는 다음과 같습니다:

    setScorer: 검색 점수를 계산하는 Scorer 인스턴스를 Collector에 설정합니다. LeafCollector가 교체될 때 필요한 추가적인 작업들을 이 메서드에서 수행할 수 있습니다.
    collect: 특정 문서가 최종 검색 결과에 포함될지를 결정하고 수집하는 작업을 합니다. 이 메서드는 쿼리와 매칭된 각 문서에 대해 한 번씩 호출되며,
    각 문서는 세그먼트 내에서의 로컬 문서 ID로 식별됩니다.
    또한, 문서 수집 과정에서 더 이상 문서를 수집할 필요가 없다고 판단되면, CollectionTerminatedException 예외를 던져 수집을 조기 종료할 수 있습니다.
    이 예외는 IndexSearcher에 의해 처리되고, 수집 과정은 다음 세그먼트로 이동하여 계속됩니다.

    엘라스틱서치는 이와 비슷한 메커니즘으로 EarlyTerminatingCollector를 구현하며, 이는 검색을 조기에 종료하는 기능을 제공하여 성능을 최적화할 때 유용합니다.

    요약하자면, Collector는 루씬 검색 엔진에서 검색 결과를 어떻게 처리할지를 정의하는 중요한 구성 요소이며, 각 세그먼트별로 문서를 효율적으로 수집하고 필요에 따라 검색을 조기
    종료할 수 있는 기능을 제공합니다.

    인덱스에 세그먼트의 개수가 많다면?
    인덱스 내에 세그먼트의 수가 많을 경우, LeafCollector가 순회해야 하는 횟수가 늘어나게 되고, 이는 성능에 영향을 미칠 수 있습니다.
    세그먼트는 루씬의 검색 엔진에서 각각 독립적으로 관리되는 문서의 집합입니다. 각 검색 쿼리는 모든 세그먼트를 순회하면서 관련 문서를 찾아내야 하기 때문에,
    세그먼트의 수가 많아지면 그만큼 검색 연산에 필요한 시간과 리소스가 증가합니다.

    세그먼트의 영향
        검색 성능: 각 쿼리는 모든 세그먼트를 확인해야 하므로, 세그먼트의 수가 많으면 검색 성능이 저하될 수 있습니다.
        리소스 사용: 더 많은 세그먼트는 더 많은 디스크 I/O와 CPU 사용을 요구할 수 있으며, 이는 시스템의 전반적인 부하를 증가시킵니다.
        세그먼트 병합 (Segment Merging)
        루씬과 엘라스틱서치는 이러한 세그먼트 관련 성능 문제를 관리하기 위해 세그먼트 병합 과정을 자동으로 수행합니다. 세그먼트 병합은 여러 작은 세그먼트를
        하나의 큰 세그먼트로 합치는 과정을 말합니다. 이 과정은 다음과 같은 장점을 제공합니다.

        검색 성능 향상: 세그먼트의 수를 줄여 검색해야 할 범위를 감소시키므로, 검색 성능이 개선될 수 있습니다.
        디스크 공간 절약: 중복된 데이터 구조를 제거하고, 삭제된 문서를 영구적으로 제거함으로써 디스크 공간을 보다 효율적으로 사용할 수 있습니다.
        관리 용이성: 세그먼트의 수가 줄어들면 인덱스의 관리가 더 간단해지고, 성능이 더 일관되게 유지됩니다.
        세그먼트 관리의 중요성
        따라서, 세그먼트의 수를 적절하게 유지하는 것은 엘라스틱서치의 성능과 효율성을 관리하는 데 매우 중요합니다. 엘라스틱서치의 인덱스
        관리 설정을 통해 세그먼트 병합 정책을 조정하고, 시스템의 성능 요구에 맞게 세그먼트 병합을 최적화할 수 있습니다.



* bool 쿼리의 검색 동작 순서와 DocIdSetIterator 순회
    검색 요청을 처리하기 위해 내부적으로 복잡한 쿼리를 간단한 루씬 쿼리들로 분해하고 이들을 조합해 재작성하는 과정을 거칩니다.
    이 과정에서 rewrite 메서드를 사용하여 쿼리를 최적화하고, 쿼리의 비용과 효율을 평가하여 실행 순서를 결정합니다.

    검색 동작 순서
        쿼리 재작성: 쿼리를 간소화하거나 더 효율적인 형태로 변환합니다.
        비용 추정: DocIdSetIterator의 cost 메서드를 사용하여 각 쿼리의 실행 비용을 추정하고, 비용이 낮은 쿼리부터 실행을 우선합니다.
        문서 순회 및 매칭: 쿼리가 여러 개일 경우, 각 쿼리의 Scorer와 DocIdSetIterator를 통해 문서 후보들을 뽑고, 실제 조건에 맞는 문서를 확인하며 병렬적으로 처리합니다.

    검색 유형
        Conjunction 검색 (AND 검색): 모든 조건을 만족하는 문서를 찾습니다. 여러 Scorer를 사용하여 각 문서 ID가 모든 조건을 충족하는지 순차적으로 확인합니다. 모든 Scorer가 동일한 문서를 가리키면 그 문서는 결과로 반환됩니다.
        Disjunction 검색 (OR 검색): 조건 중 하나라도 만족하는 문서를 찾습니다. 하위 Scorer 중 하나가 문서를 가리키면, 해당 문서는 결과로 반환됩니다.

    최적화 기법
        건너뛰기: 높은 점수를 가진 문서를 우선적으로 처리하고, 낮은 점수의 문서는 건너뛰어 검색 효율을 높입니다.
        TwoPhaseIterator: 추가 비용이 드는 매칭 조건을 처리할 때 사용되며, 저비용의 조건부터 먼저 확인하여 효율성을 극대화합니다.

    이러한 검색 메커니즘은 복잡한 쿼리를 효과적으로 처리하여 빠르고 정확한 검색 결과를 제공하는 데 도움을 줍니다. 엘라스틱서치는 이를 통해 대용량 데이터셋에서도 높은 성능을 유지할 수 있습니다.