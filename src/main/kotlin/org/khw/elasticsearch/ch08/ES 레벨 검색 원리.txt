* 엘라스틱서치 검색 동작흐름 개괄
    1) 요청
    2) RestSearchAction
        - REST API 명세를 지정하고 등록
        - REST 요청을 SearchRequest로 변경해 TransportSearchAction 수행

    3) TransportSearchAction
        - 실질적인 검색 작업의 시작
        - 검색요청의 상세
        - 현재 클러스터 상황 등을 파악하여
        - 검색 방법과 대상을 확정

    4) Query Phase
        - 쿼리에 매치되는 상위 문서 검색

    5) Fetch Phase
        - 매치된 상위 문서의 내용을 읽어 반환


* TransportSearchAction
    TransportSearchAction에서는 검색 요청과 현재 클러스터 상태를 분석해 상황에 맞는 적절한 검색 방법과 대상을 확정한다.
    여기에서 검색 대상은 구체적으로 인덱스와 샤드다. 검색 요청에 항상 구체적인 검색 대상 인덱스 이름이 들어오는 것은 아니다.
    와일드카드 문자가 포함된 인덱스 이름이 지정됐을 수 도 있고 인덱스 이름이 아니라 alias나 데이터 스트림이 지정됐을 수도 있다.,
    TransportSearchAction은 이런 다양한 검색 대상으로부터 실제 인덱스 목록을 확정한다. 인덱스를 뽑았으니 이어 구체적으로
    어떤 샤드에 검색 요청을 보낼지를 정한다. 먼저 라우팅을 이용해 몇 번 샤드에 요청을 보낼지를 확인한다.
    하지만 복제본 샤드가 있으니 같은 인덱스의 같은 번호 샤드도 여러 개가 있다.
    TransportSearchAction은 다양한 방법을 통해 여러 샤드 중 어떤 샤드에 우선해서 요청을 보낼것인지 순서를 확정한다. 우선순위가
    가장 높은 샤드 하나에 요청을 보냈을 때 실패할 수도 있으므로 순서 목록을 작성한다. 요청이 실패한 경우 필요하다면 다음 순서의
    샤드에 요청을 보내는 식으로 동작한다. TransportSearchAction은 이 목록을 ShardIterator 인터페이스의 형태로 작성한다.
    ShardIterator 작성 시 먼저 요청의 preference 값을 읽는다.

    preference는 검색 시 어떤 노드와 샤드를 우선해서 검색할 것인지 지정하는 매개변수다.
    검색 시 GET my_index/_search?preference=_local과 같이 요청한 경우를 가정하자.
    TransportSearchAction은 로컬에 원하는 샤드가 있는지를 먼저 체크한 뒤 없다면 다른 노드의 샤드를 대상으로 지정한다.

    ** preference 옵션
        ㄴ _only_local : 로컬에 들고 있는 샤드만을 대상으로 검색을 수행한다.
        ㄴ _local : 가능하면 로컬에 들고 있는 샤드를 우선으로 검색을 수행한다. 불가능하다면 다른 노드의 샤드를 대상으로 지정한다.
        ㄴ _only_nodes:<node-id>,<node-id> : 지정한 노드 ID가 들고 있는 샤드를 대상으로만 검색을 수행한다.
            노드 ID는 GET _nodes에서 확인할 수 있는 노드의 ID로 지정해도 되고 노드의 이름으로 지정해도 된다.
            - 여기에 지정한 노드 목록은 검색 대상이 될 샤드를 들고 있어야 한다. 예를 들어 number_of_shards가 3인 my_index에 대해
            GET my_index/search?preference=_only_nodes=node01,node02와 같이 검색했다면 node01과 node02를 합쳤을 때
            0번, 1번, 2번 샤드를 모두 들고 있어야 한다. 검색 대상이 될 샤드를 들고 있어야 하는 것이기 때문에 인덱스의 모든 샤드를
            들고 있어야 하는 것은 아니다
        ㄴ _prefer_nodes:<node-id>,<node-id>: 지정한 노드 ID가 들고 있는 샤드를 우선해서 검색한다.
        ㄴ _shards:<shard>,<shard>: 샤드 번호를 직접 지정해 해당 샤드 대상으로만 검색을 수행한다.
            _shards:0,1|_local 과 같이 | 문자를 이용해서 뒤에 다른 preference 값을 조합할 수 있다.

    preference가 지정되지 않았다면 엘라스틱서치는 해당 샤드를 가진 노드 중 적절한 노드를 선정한다. 또 이 조정 노드에서 보낸 이전 요청에 대한
    응답 속도나 이전 검색 요청에 시간이 얼마나 소요됐는지 등 그간의 통계 데이터와 현재 검색 스레드 풀 상황이 어떠한지를 고려해 가장 응답을
    빨리 돌려줄 것으로 예상되는 노드를 선정한다. 이렇게 샤드를 선택하는 방법을 adaptive_replica selection이라고 한다.
    기본적으로 활성화돼 있지만 cluster.routing.use_adaptive_replica_selection 클러스터 설정을 false로 지정해 끌 수도 있다.
    이런 상황이면 랜덤으로 노드를 선정한다.

* CanMatchPreFilterSearchPhase
    검색 요청의 search_type이 query_then_fetch이고 몇몇 특정 조건을 만족하면 엘라스틱서치는 본격적인 검색 작업이 들어가기 전에
    CanMatchPreFilterSearchPhase를 먼저 거치며 몇 가지 최적화를 수행한다. CanMatchPreFilterSearchPhase는
    검색 대상의 샤드 수가 128개를 초과하거나 검색 대상이 읽기 전용 인덱스를 포함하거나,  첫번째 정렬 기준에 색인된 필드가 지정된 경우 수행된다.

    CanMatchPreFilterSearchPhase는 검색 대상 샤드에서 주어진 쿼리로 단 하나의 문서라도 매치될 가능성이 있는지 사전에 가벼운 점검을 수행해
    확실히 검색 대상이 될 필요가 없는 샤드를 사전에 제거한다. 조정 노드에서 수행할 수 있는 점검을 마친 뒤에는 각 샤드별 점검 요청을 노드 단위로
    묶어 만들어 transport 채널로 분산 전송한다. 요청을 수신한 노드는 SearchService의 canMatch 메서드를 수행하며 사전 작업을 수행한다.
    이 사전 작업의 비용은 낮은 편이다.

    CanMatchPreFilterSearchPhase의 최적화 과정에서는 인덱스의 메타데이터를 이용해 타임스탬프 필드 범위상 매치되는 문서가 확실히 없는지를
    체크한다거나 첫 번째 정렬 기준으로 색인된 필드가 지정되어 있으면 각 샤드의 최솟값과 최댓값을 가지고 샤드를 정렬해 상위에 올라온 문서를 보유한
    샤드가 먼저 수행되도록 최적화하는 등 다양한 방법이 사용된다.

* AbstractSearchAsyncAction
    search_type의 기본값은 query_then_fetch다. 각 샤드에서 검색 쿼리를 수행하고 매치된 상위 문서를 수집할 때 유사도 점수 계산을 끝내는 가장
    일반적인 형태의 검색이다. 이 형태의 검색은 SearchQueryThenFetchAsyncAction 클래스에서 전체적인 흐름을 제어한다.

    search_type을 dfs_query_then_fetch로 지정하면 모든 샤드로부터 사전에 추가 정보를 모아 정확한 유사도 점수를 계산한다.
    이 경우 정확도는 올라가지만 성능이 떨어진다. 이 형태의 검색은 SearchDfsQueryThenFetchAsyncAction 클래스에서 전체적인 흐름을 제어한다.
    여기서 DFS는 distributed frequency search의 약자다.

    SearchQueryThenFetchAsyncAction과 SearchDfsQueryThenFetchAsyncAction은 모두 AbstractSearchAsyncAction 추상 클래스를 확장하고 있다.
    AbstractSearchAsyncAction 추상 클래스는 검색 대상 샤드별로 샤드 검색 요청을 만들어 분산 전송한 뒤 응답을 수집하고 다음 페이즈로 이동하는 등
    검색의 전체적인 흐름을 제어하는 역할을 수행한다.

* SearchPhase
    검색 동작은 다음 페이즈로 전환되는 부분을 중점으로 보면 흐름을 읽기가 편하다. 그리고 해당 페이즈의 작업이 조정 노드에서 수행하는 작업인지 아니면
    각 샤드 레벨에서 수행하는 작업인지 구분해서 봐야한다.
    - 샤드레벨에서 수행하는 작업 : QueryPhase, DfsPhase, FetchPhase, SuggestPhase, AggregationPhase
    - 조정 노드에서 수행하는 작업 : TransportSearchAction, TransportMultiSearchAction
        CanMatchPreFilterSearchPhase(범위상 검색 대상이 될 필요가 없는 샤드 등을 제거하여 최적화),
        SearchQueryThenFetchAsyncAction(각 샤드에서 유사도 점수 계산을 끝내는 일반적인 검색)
        SearchDfsQueryThenFetchAsyncAction(모든 샤드로부터 정보를 모아 정확한 유사도 점수를 계산 정확도는 올라가지만 성능이 떨어짐),
        DfsQueryPhase,
        FetchSearchPhase,
        ExpandSearchPhase

    엘라스틱서치는 검색 동작을 페이즈 단위로 구분해 수행하기 위해 SearchPhase라는 추상 클래스를 사용한다. 주로 한 SearchPhase의 작업이 끝나면
    지정한 다음 SearchPhase로 넘어가서 작업을 이어가는 흐름으로 구현하고 있다. 검색 동작 구현에 연루되는 주요 클래스 중 Phase라는 이름이 붙은
    클래스가 상당히 많은데 이 중 어떤 클래스는 SearchPhase를 확장하고 있고 어떤 클래스는 그렇지 않기 때문에 혼동하기 쉽다.
    조정노드에서 수행하는 페이즈만 SearchPhase를 확장한다는 사실을 알아두면 구분이 쉽다.
    갹 샤드에서 수행하는 작업인 DfsPhase, QueryPhase, SuggestPhase, AggregationPhase, FetchPhase와 같은 클래스는 SearchPhase를 확장하지 않는다.

* SearchDfsQueryThenFetchAsyncAction
    search_type이 dfs_query_then_fetch 였다면
    검색은 SearchDfsQueryThenFetchAsyncAction으로 시작한다. 점수 계산에 사용할 추가정보를 각 샤드에서 가져오기 위해 샤드별 요청을 만들어
    분산 전송한다. 이 요청을 수신한 각 노드는 SearchService의 executeDfsPhase 메서드를 호출한다.


    ** ReaderContext
        정의: ReaderContext는 검색 요청이 처리되는 동안 사용되는 리더(인덱스에서 데이터를 읽는 컴포넌트)의 상태와 정보를 포함합니다.
            이 컨텍스트는 검색 작업 동안 필요한 다양한 리소스와 정보에 대한 액세스를 제공하며, 검색의 일관성을 유지하는 데 중요한 역할을 합니다.
        역할: 특히, ReaderContext는 검색 쿼리가 실행되는 시점의 인덱스 상태를 나타내며, 이를 통해 검색이 일관된 데이터 스냅샷에 대해 수행될 수 있도록 보장합니다.
            이는 검색 도중 데이터가 변경되더라도 결과의 일관성을 유지하는 데 중요합니다.
    ** Point In Time (PIT)
        정의: PIT는 Elasticsearch에서 데이터의 일관된 스냅샷을 참조하기 위한 메커니즘입니다. PIT를 사용하면 검색 요청이 처리되는 동안 인덱스의
            상태가 유지되므로, 검색 결과의 일관성이 보장됩니다.
        역할: PIT는 검색이 시작되는 시점의 인덱스 상태를 "고정"하고, 이 스냅샷에 대해 검색을 수행합니다. 이는 검색 도중 인덱스에 변경 사항이 발생하더라도,
            해당 검색 요청이 처음 시작될 때의 데이터 상태에 대해 결과를 반환함으로써 결과의 일관성을 유지합니다.

    이 메서드에서는 먼저 ReaderContext를 가져오거나 새로 생성한다. 검색 요청을 만드는 단계에서 pit 등 기존 문맥을 활용하도록 지정되어 있었다면
    이미 생성된 ReaderContext가 노드에 존재하므로 그것을 가져온다. 가져올 수 없는 경우 ReaderContext를 새로 생성해 노드에 일정 시간동안 저장해 둔다.
    ReaderContext에는 문맥을 생성하는 그 시점의 샤드를 대상을 검색을 수행하는 루씬 IndexSearcher가 담긴다. 즉 나중에 ReaderContext를 재활용 하면
    항상 같은 상태의 샤드를 대상으로 검색을 수행한다. pit에서 활용하는 기능이다.

    ReaderContext 생성 이후 DfsPhase 작업을 수행한다. DfsPhase에서는 검색 쿼리에 매치되는 텀이나 문서 빈도, 여러 통계 데이터 등을 구해 반환한다.
    SearchDfsQueryThenFetchAsyncAction은 그 응답을 다 받은 뒤 executeNextPhase 메서드를 호출해 다음 페이즈인 DfsQueryPhase로 넘어간다.

* DfsQueryPhase
    DfsQueryPhase는 각 샤드에서 보낸 DfsPhase 작업 결과로부터 샤드별 본 검색 요청을 만들어 다시 각 노드로 분산 전송한다. 이 요청을 수신한 노드는
    SearchService의 executeQueryPhase 메서드를 거쳐 QueryPhase에서 본격적인 쿼리 매치 작업을 수행한다. 각 샤드의 QueryPhase의 작업 결과를
    수신하면 다음 페이즈인 FetchSearchPhase로 넘어간다.

* SearchQueryThenFetchAsyncAction
    다시 AbstractSearchAsyncAction으로 돌아오자. search_type이 query_then_fetch였다면 가장 일번적인 검색 방법인 SearchQueryThenFetchAsyncAction로
    시작한다. SearchQueryThenFetchAsyncAction은 사전 작업 없이 바로 샤드별 검색 요청을 만들어 전송한다. 마찬가지로 이 요청을 수신한 노드는
    SearchService의 executeQueryPhase 메서드를 거쳐 QueryPhase에서 본격적인 쿼리 매치 작업을 수행한다. 각 샤드의 작업 결과를 수신하면
    FetchSearchPhase로 넘어가는 것도 동일하다.

* QueryPhase
    SearchQueryThenFetchAsyncAction이나 DfsQueryPhase의 검색 요청을 수신한 노드는 SearchService의 executeQueryPhase 메서드를 호출한다.
    여기서 ReaderContext를 가져오거나 새로 생성한다. 요청에 pit가 지정됐다면 pit로부터, DfsPhase를 거쳐왔다면 DfsPhase에서 생성했던
    ReaderContext를 가져와 재활용한다. 마찬가지로 ReaderContext를 가져올 수 없다면 새로 생성하고 노드에 저장한다.

    ReaderContext를 확보한 다음에 샤드 요청이 캐시 가능한 요청인지 확인한다. 여기서의 캐시는 샤드 레벨에 저장되는 캐시다. 캐시 가능한 요청이라면
    캐시에서 값을 불러와 바로 응답을 반환한다. 캐시에 값이 없다면 QueryPhase의 주 작업을 수행하고 캐시에 결과를 저장한다.
    캐시 불가능한 요청이라면 쿼리 매치 작업만을 수행한다.

    이후 QueryPhase의 execute에서 주 작업을 수행한다. QueryPhase에서는 크게 검색, 제안(suggest), 집계의 세 작업을 수행한다. 검색 작업은 루씬의
    IndexSearcher, Query, Collector를 이용해 쿼리에 매치되는 상위 문서를 수집하는 작업이다. 제안 작업은 오타 교정이나 자동 완성 등에 사용하는 기능으로
    SuggestPhase 클래스에서 수행한다. 집계 작업은 AggregationPhase 클래스에서 수행한다.

* FetchSearchPhase와 FetchPhase
    각 샤드가 수행한 QueryPhase 작업의 결과가 조정 노드에 모이면 FetchSearchPhase로 넘어간다.
    FetchSearchPhase는 QueryPhase의 작업 결과를 모아 병합하고 각 샤드에 요청할 fetch 요청을 생성해 분산 전송한다. 이 요청을 받은 각 노드는
    SearchService의 executeFetchPhase를 호출한다. executeFetchPhase는 먼저 ReaderContext를 찾는다. 여기서 이전 페이즈나 pit등으로
    생성했던 ReaderContext를 그대로 재활용하기 때문에 매치 작업 때와 동일한 문서를 읽어 오는 구조다. ReaderContext를 확보했으면
    FetchPhase의 execute를 호출해 요청에 지정한 번호의 문서 내용을 실제로 읽는다. 이후 ReaderContext가 pit이나 scroll이 아니라
    단발성 쿼리를 위한 문맥이었다면 ReaderContext를 해제한다. 그리고 fetch 결과를 조정 노드로 반환한다. 각 샤드의
    FetchPhase 작업 결과가 조정 노드에 모이면 다음 페이즈인 ExpandSearchPhase로 넘어간다.

* FetchSubPhase
    FetchSubPhase 인터페이스는 FetchPhase 작업 중 문서 내용을 읽어 SearchHit을 만드는 과정에서 수행하는 여러 하위 작업을 구현하는 인터페이스다.
    FetchSubPhase 인터페이스의 구현체는 SearchModule에 등록한다. 커스텀 플러그인을 통해 직접 만든 FetchSubPhase를 등록할 수도 있다.
    기본적으로 등록된 FetchSubPhase 인터페이스 구현체로는 _source를 읽어오는 FetchSourcePhase,
    _source를 다시 계산해 가져오는 FetchScorePhase, 검색 수행 중간 과정과 부분 유사도 점수를 상세 설명하는 _explanation을 만드는
    ExplainPhase 등이 있다.

* ExpandSearchPhase
    ExpandSearchPhase는 필드 collapse를 위한 페이즈다. 필드 collapse는 지정한 필드 값을 기준으로 검색 결과를 그룹으로 묶은 뒤 그 안에서
    다른 기준으로 상위 문서를 지정한 개수만큼 뽑을때 사용하는 특수한 기능이다.

    ** collapse
        collapse는 검색 쿼리에 추가되는 파라미터로, 특정 필드의 값이 같은 문서들 중에서 어떤 문서를 검색 결과에 포함시킬지 결정합니다.
        이 기능은 주로 검색 결과의 다양성을 증가시키거나, 중복된 정보의 표시를 최소화하는 데 목적을 둡니다.
        GET /_search
        {
          "query": {
            "match": {
              "content": "Elasticsearch"
            }
          },
          "collapse": {
            "field": "category"
          }
        }
        위 예시에서는 "category" 필드를 기준으로 검색 결과를 축소(collapse)합니다. 이 경우, 각 카테고리에 대해 최상위에 랭크된 문서 하나만이 결과에 포함되며,
        같은 카테고리를 가진 나머지 문서들은 제외됩니다.

    ExpandSearchPhase에서는 필드 collapse를 수행하기 위해 본 검색의 hit 수만큼 새 검색 요청을 만들어 MultiSearchRequest에 담는다.
    이 MultiSearchRequest는 로컬에 전송되며 즉 조정 노드 자신이 이를 다시 받는다. 해당 작업은 TransportMultiSearchAction에서 처리하는데,
    이 다중 검색의 세부 요청들은 다시 TransportSearchAction이 받아서 수행한다.
    TransportSearchAction은 독립적인 새 검색을 수행하는 것과 동일한 절차로 검색 작업을 수행해 결과를 조정 노드에 돌려준다.

    응답을 수신한 ExpandSearchPhase는 결과를 모아 최종 검색 결과를 만들어 반환하고 검색 작업을 종료한다.
    필드 collapse를 사용하지 않는다면 바로 검색 결과를 반환한다.

    ExpandSearchPhase가 반환한 InternalSearchResponse를 최종 응답 모양인 SearchResponse로 변환하는 작업은 다시
    AbstractSearchAsyncAction으로 돌아와 수행한다. 정말로 AbstractSearchAsyncAction이 검색의 전체적인 흐름을 쥐고 있는 셈이다.