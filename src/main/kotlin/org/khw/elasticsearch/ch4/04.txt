* 색인 API
    PUT [인덱스이름]/_doc/[id값]
    POST [인덱스이름]/_doc/
    PUT [인덱스이름]/_create/[id값]
    POST [인덱스이름]/_create/[id값]
    _doc 와 _create API 차이점은 _doc는 id값이 중복되면 해당 문서를 덮어씌우고 _create는 id 값이 중복되면 문서 색인 실패 예외 발생


* 색인시 라우팅
    색인 시 routing을 매개변수로 지정해주지 않으면 _id값을 해시값 기반으로 샤드에 배정

* refresh
    색인 시 refresh 매개변수를 지정하면 문서를 색인한 직후에 해당 샤드를 refresh해서 즉시 검색 가능하게 만들것인지 여부 지정가능
        - true : 색인 직후 문서가 색인된 샤드를 refresh하고 응답을 반환한다
        - wait_for : 색인 이후 문서가 refresh될 때까지 기다린 후 응답을 반환 true로 지정했을때와는 다르게 refresh를 직업 유발하지 않는다
            너무 많은 refresh 가 대기중인 경우 강제로 refresh가 수행될 수 있다
            ㄴ index.refresh_interval 값의 크기만큼 응답 시간이 지연될 수 있다 기본값 1초
            ㄴ index.max_refresh_listeners 설정값 이상의 요청이 refresh 대기하는 중이라면 강제로 refresh가 수행됨
        - false : 아무 값도 지정하지 않았을 때 기본값이다. refresh와 관련된 동작을 수행하지 않는다.


* 조회 API
    문서 단건 조회 API
    조회 API는 검색과는 다르게 색인이 refresh 되지 않은 상태에서도 변경된 내용을 확인할 수 있다, translog에서도 데이터를 읽어올 수 있기 때문이다
    그래서 색인 API 호출후 바로 문서조회가 필요할시 인덱스 refresh가 필요없는 조회 API 사용 권장

    GET [인덱스이름]/_doc/[_id값] // 본문과 문서의 메타데이터 함께 조회
    GET [인덱스이름]/_source/[_id값] // 문서의 본문만 조회 _source 메타 필드에 저장된 내용

    * 필드 필터링
        GET my_index2/_doc/1?_source_includes=p*,views
            ㄴ p로 시작하는 필드와 직접 명시한 views 필드만 _source 메타 필드 결과에 포함해 조회
        GET my_index2/_doc/1?_source_includes=p*,views&_source_excludes=public
            ㄴ p로 시작하는 필드와 직접 명시한 views 필드와 public 필드는 제외후 _source 메타 필드 조회
            ㄴ 특정 필드 제외


    * 라우팅
        조회 API도 색인 API와 마찬가지로 라우팅을 반드시 제대로 지정해야 한다. 색인했을 때 사용한 라우팅 값과 동일한 라우팅 값을 사용해
        조회해야 의도하는 문서 조회 가능

        GET routing_test/_search?routing=myid2

* 업데이트 API
    업데이트 API는 지정문서 단건 업데이트
    POST 메서드 _doc 대신 _update를 사용
    업데이트 API는 기본적으로 부분업데이트를 사용하나 업데이트는 기존 문서와 변경될 문서를 병합하여 새 문서를 색인하는 방식이다 보니
    _source 메타 필드를 비활성화 시켰다면 업데이트 API 사용 불가

    * _doc 내욜을 직접 기술하여 업데이트
        POST update_test/_update/1
        {
          "doc": {
            "views": 39,
            "updated" : "2019-01-23T17:00:02.867Z"
          }
        }

    * detect_noop
       업데이트 내용이 기존 문서의 내용을 실질적으로 변경 여부를 확인해 noop 요청(no operation)인지를 확인하고 noop 요청이라면 쓰기 작업 수행X
       그리고 응답의 result 필드에서 noop을 확인 가능
       noop를 검사하는 것은 불필요한 디스크 i/o를 줄일 수 있다

    * doc_as_upsert
        업데이트 하려는 문서가 없을 때에는 새로 문서를 추가한다
        doc_as_upsert 옵션을 true로 지정

        POST update_test/_update/4
        {
          "doc": {
            "views" : 58
          },
          "doc_as_upsert" : true
        }

    * painless 스크립팅을 이용한 업데이트
        POST update_test/_update/4
        {
          "script": {
            "source": "ctx._source.views += params.amount",
            "lang": "painless",
            "params": {
              "amount" : 1
            }
          },
          "scripted_upsert": false
        }

        - script: script를 이용해서 업데이트를 수행할 때는 그 내용을 위와 같이 script 필드 안에 기술한다 만약
            요청분문에 doc 필드도 함께 포함됐다면 doc을 이용한 업데이트는 무시되고 script 내용만 적용
        - source: source는 스크립트 본문이 기술되는 부분
        - lang: 스크립트 언어의 종류 지정 기본값은 painless
        - params 아래에는 스크립트 본문에서 사용할 매개변수의 값들을 넣어둘 수 있다 읽기 전용이기 때문에 스크립트 내에서의 변경은 불가능
        - scripted_upsert: 스크립트를 사용한 업데이트가 upsert로 동작하도록 할지를 지정

        스크립트를 사용한 업데이트에서는 ctx 변수를 통해 문서의 내용이나 메타데이터 등에 접근 가능
        params : 업데이트 요청에서 params로 제공한 매개변수의 Map이다 읽기 전용
        ctx._source: 문서의 _source를 Map 형태로 반환한다 이 값은 변경 가능
        ctx.op : 작업의 종류를 String으로 나타낸다
        ctx.now : 현재 타임스탬프값을 미리세컨드로 반환. 읽기 전용
        ctx._index , _id, _type, _routing, _version : 문서의 각 메타데이터를 반환. 모두 읽기 전용

* 삭제 API
    지정한 문서 하나를 삭제 DELETE [인덱스 이름]/_doc/[_id값]
    색인 API, 업데이트 API와 마찬가지로 routing, refresh 옵션 지정 가능

* bulk API
    여러 색인, 업데이트, 삭제 작업을 한 번의 요청에 담아서 보내는 API 작업 순서는 보장되지 않는다(동일한 문서는 순서대로 동작)
    요청 본문을 JSON이 아니라 NDJSON 형태로 보낸다 NDJSON은 여러줄의 JSON을 줄바꿈 문자로 구분하여 요청을 보내는 형태
    Content-Type 헤더도 application/json 대신 application/x-ndjson을 사용 줄바꿈 문자 \n \n앞에 캐리지 리턴문제 \r 오는 건 상관없다

    POST _bulk
    {"index":{"_index":"bulk_test", "_id":"1"}}
    {"field1":"value1"}

    {"delete":{"_index":"bulk_test", "_id":"2"}}

    {"create":{"_index":"bulk_test", "_id":"3"}}
    {"field1":"value3"}

    {"update": {"_id":"1", "_index":"bulk_test"}}
    {"doc":{"field2":"value2"}}

    {"index": {"_index":"bulk_test", "_id":"4", "routing":"a"}}
    {"field1":"value4"}

        ** Index API는 새 문서를 추가하거나 기존 문서를 업데이트하는 데 사용됩니다. 문서 ID가 이미 존재하면 해당 문서는 새 내용으로 업데이트됩니다.
           Create API는 오직 새 문서를 색인하는 데 사용되며, 주어진 ID가 이미 존재하는 경우 작업이 실패합니다. 이는 중복을 방지하고 싶을 때 유용합니다.
            ㄴ 문서 중복시 document_already_exists_exception 오류 발생


* multi get API
    _id를 여럿 지정해 해당 문서를 한 번에 조회하는 API
    요청 본문에는 docs 필드 밑에 각 세부 조회 요청을 기술 각 세부 요청은 _index, _id를 포함해야 하며
    라우팅이나 특정 필드 포함 및 제거 옵션들을 기술 가능
    GET _mget
    {
      "docs": [
        {
          "_index": "bulk_test",
          "_id" : 1
        },
        {
          "_index": "bulk_test",
          "_id" : 4,
          "routing" : "a"
        },
        {
          "_index" : "my_index2",
          "_id": "1",
          "_source": {
            "include": ["p*"],
            "exclude": ["point"]
          }
        }
      ]
    }

    _mget 앞에 인덱스 이름을 명시했으면 _index 생략 가능 이때 요청 본문에 docs가 아니라 ids만을 기술해 요청 가능
    GET bulk_test/_mget
    {
      "ids" : ["1", "3"]
    }

* update by query
    검색 쿼리를 통해 주어진 조건을 만족하는 문서를 찾으 뒤 그 문서를 대상으로 업데이트나 삭제 작업을 실시하는 API
    스크립트를 통한 업데이트만을 지원 또한 painless 스크립트 문맥 중 ctx._now 사용 불가
    ES는 query 절의 검색 조건에 맞는 문서를 찾아 일종의 스냅샷을 찍는다 이후 각 문서마다 지정된 스크립트에 맞게 업데이트를 하는데
    업데이트가 순차적으로 진행되는 도중 다른 작업으로 해당 문서의 변경이 생기면 스냅샷 찍은 문서와 비교후 차이점이 발생하면 업데이트를 하지 않는다
    이렇게 버전 충돌이 발생하면 conflicts 매개변수를 지정해 동작방식 지정 가능
    abort(기본값)로 지정하면 충돌 발견 시 작업 중단, proceed로 지정하면 다음 작업으로 넘어간다
    업데이트가 중단 되어도 중단 전 까지의 업데이트 결과가 롤백 되지는 않는다

    // bulk_test 인덱스 내 field1 이라는 필드가 존재하는 문서를 대상으로 업데이트
    POST bulk_test/_update_by_query
    {
      "script": {
        "source": "ctx._source.field1 = ctx._source.field1 + '-' + ctx._id",
        "lang": "painless"
      },
      "query": {
        "exists": {
          "field": "field1"
        }
      }
    }

    * 스로틀링
        update by query API는 관리적인 목적으로 수행되는 경우가 많다(문제가 생긴 데이터를 일괄처리 등)
        적절한 스로틀링을 적용해 작업의 속도를 조저하고 클러스터 부하와 서비스 영향을 최소화 가능

        POST bulk_test/_update_by_query?scroll_size=1000&scroll=1m&requests_per_seconds=500
        {
            ...
        }

        {
            "throttled_millis": 5, // 작업을 진행하지 않고 대기한 총 시간
              "requests_per_second": 500,
              "throttled_until_millis": 0,
        }

        - scroll_size = 검색 수행시 가져올 문서의 개수 디폴트 : 1000
        - scroll : 검색된 문서의 스냅샷 유지 시간 디폴트 1m
        - requests_per_second : 초당 몇 개까지의 작업을 수행할지 디폴트 : -1
            ㄴ scroll_size 단위로 업데이트 수행 후 requests_per_second 값에 맞도록 일정 시간을 대기할 수 있다

    * 비동기적 요청과 task API
        update by query 요청 시에는 wait_for_completion 매개 변수를 false로 지정하면 비동기적 처리 가능
        해당 요청을 받으면 ES는 작업을 task로 등록한뒤 즉시 task의 id가 포함된 응답을 반환
        엄밀히 말하면 모든 수행 중인 update by query는 wait_for_completion 값이 상관없이 모두 task 형태로 동작
        wait_for_completion = false로 지정하면 진행 상황이 .tasks라는 내부 인덱스에 문서로 저장

        POST bulk_test/_update_by_query?scroll_size=1000&scroll=1m&requests_per_second=500&wait_for_completion=false
        {
          "script": {
            "source": "ctx._source.field1 = ctx._source.field1 + '-' + ctx._id",
            "lang": "painless"
          },
          "query": {
            "exists": {
              "field": "field1"
            }
          }
        }

        {
            "task": "6AJgkg6-SJCN3vfvs21xIA:89377" // 결과가 task id만 반환 노드의 id:task id 연결한 값
        }

        GET .tasks/_doc/6AJgkg6-SJCN3vfvs21xIA:87990 // 내부 인덱스인 .tasks 의 문서를 문서 조회 API로 확인
        GET _tasks/6AJgkg6-SJCN3vfvs21xIA:87990 // tasks 관리 API 중 조회 API 호출

    * task 취소
        POST _tasks/6AJgkg6-SJCN3vfvs21xIA:94796/_cancel
        취소한 task는 status : {"canceled" : "by user request"} 필드가 추가

    * 동적 스로틀링
        POST _update_by_query/[task_id]/_rethrottle?requests_per_second=[변경할 값]

    * task 결과 삭제
        DELETE .tasks/_doc/[task id]

    * 슬라이싱
        update by query의 검색과 업데이ㅡ를 지정한 개수로 쪼개 병렬적으로 수행
        slices=auto auto로 지정하면 ES가 적절한 개수를 지정해서 작업을 병렬 수행한다 보통은 지정한 인덱스의 주 샤드 수가
        슬라이스의 수가 된다

* delete by query
    POST [인덱스 이름]/_delete_by_query
    {
        "query": {

        }
    }

    검색 조건에 맞는 문서를 찾아 스냅샷을 찍는다 삭작업이 진행되는 동안 문서의 내용이 변경됐다면 버전 충돌이 일어나는 부분도
    update by query와 동일
    버전 충돌 시 작업 여부를 지정하는 conflicts 매개변수, .tasks 인덱스에 작업 등록과 비동기적 실행을 위한 wait_for_completion 매개변수,
    tasks API를 통한 관리 스로틀링적용, 슬라이싱 적용 등 update by query와 동일