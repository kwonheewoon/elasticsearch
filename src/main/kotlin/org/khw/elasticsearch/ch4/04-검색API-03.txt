*from과 size
    from : 몇 번째 문서부터 겨로가를 반환할지 오프셋을 지정
    size : 검색 결과로 몇 개의 문서를 반환할 것인지 지정
    GET [인덱스]/_search
    {
        "from": 10,
        "size": 5,
        "query": {
            // ...
        }
    }
    from 15, size 5 로 지정해 검색했을시 내부적으로는 상위 20개의 문서를 수집하는 검색을 다시 수행한 뒤 마지막에 결과의 일부를 잘라내서 반환하는 방식으로
    동작 from 값이 올라갈수록 매우 무거운 검색을 수행 이는 cpu와 메모리 사용량을 크게 증가시키고 심각하면 장애를 유발할 수도 있다 페이지가 넘어갈 수록
    인덱스의 상태가 실시간으로 변한다(새롭게 추가되거나, 삭제되는 문서가 존재함)
    특정 시점의 데이터를 중복이나 누락 없이 엄밀하게 페이지네이션 하려면 from과 size는 사용하지 말아야 한다
    index.max_result_window = 10000 from / size를 조합해 검색할 수 있는 최대 윈도우 크기

*scroll
    검색 조건에 매칭되는 전체 문서를 모두 순회해야 할 때 적합한 방법
        ㄴ 서비스에서 지속적인 호출을 의도하고 만들어진 기능이 아닌
        ㄴ 주로 대량의 데이터를 다른 스토리지로 이전하거나 덤프하는 용도로 사용
    스크롤을 순회하는 동안에는 최초 검색 시의 문맥이 유지, 중복이나 누락도 발생하지 않는다
    메모리 사용: 스크롤을 사용할 때, 엘라스틱서치는 검색 결과의 전체 세트를 한 번에 메모리에 로드하는 것이 아니라, 요청에 따라 필요한 부분만을 순차적으로 처리합니다. 이는 대량의 데이터를 효율적으로 다룰 수 있게 해주며, 메모리 사용을 최적화합니다.
    GET mapping_test/_search?scroll=1m
    // response
    {
      "_scroll_id": "FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFkhLeXMtSDZsUjdXdFpkWGxERHA5UHcAAAAAAAAUZRY2QUpna2c2LVNKQ04zdmZ2czIxeElB"
      ...
    }
    반환된 scroll_id를 body로 요청시 더 이상 문서가 봔환되지 않을 때까지 scroll검색을 반복
    GET _search/scroll
    {
      "scroll_id" : "FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFkhLeXMtSDZsUjdXdFpkWGxERHA5UHcAAAAAAAAVMxY2QUpna2c2LVNKQ04zdmZ2czIxeElB",
      "scroll": "1m"
    }
    문맥 유지시간이 지나면 자동 삭제되지만 DELETE 요청을 보내 삭제 가능
    DELETE _search/scroll
    {
      "scroll_id" : "FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFkhLeXMtSDZsUjdXdFpkWGxERHA5UHcAAAAAAAAVMxY2QUpna2c2LVNKQ04zdmZ2czIxeElB"
    }
    검색 결과의 정렬 여부가 상관없다면 _doc 메타필드를 정렬기준으로 지정하는게 좋다 유사도 점수에 따른 정렬을 하지 않으며 정렬을 위한 별도의 자원도 사용하지
    않는다(디스크에서 문서의 저장 순서를 더 빠르게 읽을 수 있다)

* 동점 제거용 필드
    검색 결과에서 여러 문서가 동일한 유사도 점수(_score)를 가질 때, 이들의 순서를 결정하기 위해 사용되는 추가적인 필드
    "sort": [
        "_score", // 먼저 점수에 따라 정렬
        {
          "creation_date": "asc" // 점수가 같은 경우 생성 날짜로 정렬
        }
      ]
    _id 필드는 doc_values(캐싱)이 꺼져 있기 때문에 이를 기준으로 하는 정렬은 많은 메모리를 사용
        _id를 정렬 기준으로 사용할거면 _id 값과 동일한 값을 가지는 필드를 생성하고 이를 기준으로 정렬하는게 낫다

*search_after
    순차적 접근: search_after는 주어진 정렬 기준에 따라 이전 검색 결과 뒤의 데이터를 계속해서 검색할 수 있게 합니다.
    각 검색 요청은 마지막으로 반환된 문서의 정렬 값 다음에 위치한 문서부터 시작하여, 정렬 순서에 따라 다음 세트의 문서를 반환합니다.
    검색 컨텍스트: 첫 번째 검색 요청 시에 사용된 정렬 기준은 모든 이후의 search_after 요청에도 동일하게 적용되어야 합니다.
    이는 엘라스틱서치가 각 요청을 독립적으로 처리할 수 있게 하며, 각 요청은 단순히 이전 요청의 "이후" 데이터를 검색합니다.
    GET kibana_sample_data_ecommerce/_search
    {
      "size": 20,
      "query": {
        "term": {
          "currency": {
            "value": "EUR"
          }
        }
      },
      "sort": [
        {
          "order_date": "desc"
        },
        {
          "order_id": "asc"
        }
      ]
    }
    // response
    // sort 값을 다음 검색의 search_after에 포함시켜 검색요청
    {
        "sort": [ // 이 값은 검색된 마지막 문서의 sort 필드 값이다 order_date, order_id를 sort 필드로 지정했으면 해당 필드의 값이다
                  1709411990000,
                  "591924"
                ]
    }

* point in time API
    search_after를 사용할 때 인덱스 상태를 특정 시점으로 고정
    POST kibana_sample_data_ecommerce/_pit?keep_alive=1m
    //response
    {
      "id": "697qAwEca2liYW5hX3NhbXBsZV9kYXRhX2Vjb21tZXJjZRZ2LXR6bnVQZVFLS3NZbWtSS0E5UjBRABY2QUpna2c2LVNKQ04zdmZ2czIxeElBAAAAAAAAACSXFkhLeXMtSDZsUjdXdFpkWGxERHA5UHcAARZ2LXR6bnVQZVFLS3NZbWtSS0E5UjBRAAA="
    }

    // pit id 값을 검색쿼리에 추가 후 검색 가능
    // pit id를 지정하는 것 자체가 검색 대상을 지정하는 것이기 때문에 인덱스 지정 안해도 됨
    GET _search
    {
      "size": 20,
      "query": {
        "term": {
          "currency": {
            "value": "EUR"
          }
        }
      },
      "pit": {
        "id": "697qAwEca2liYW5hX3NhbXBsZV9kYXRhX2Vjb21tZXJjZRZ2LXR6bnVQZVFLS3NZbWtSS0E5UjBRABY2QUpna2c2LVNKQ04zdmZ2czIxeElBAAAAAAAAACVUFkhLeXMtSDZsUjdXdFpkWGxERHA5UHcAARZ2LXR6bnVQZVFLS3NZbWtSS0E5UjBRAAA=",
        "keep_alive": "1m"
      },
      "search_after": [
        1709411990000,2438],
      "sort": [
        {
          "order_date": "desc"
        },
        {
          "order_id": "asc"
        }
      ]
    }